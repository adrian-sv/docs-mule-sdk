= Configure Operations
ifndef::env-site,env-github[]
include::../_attributes.adoc[]
endif::[]

== Operations Identifier
REST SDK heavily relies on the operation identifier for the resources’ classes generation, that operation identifier could be fetched from the OAS model under `operationId` or if it’s from a RAML model it will default to null.

The importance of the identifier is that it must not collide with other resources (nor triggers, or any other type of REST SDK component) and that it can be modified in the descriptor by comprehension. REST SDK does provide a default mechanism for generating that resource identifier, in which if there’s a valid operationId (from an OAS context) with a non null value, it will use it, or it execute the fallback of using the HTTP method plus the resource name (which is unique in an API).

But there are scenarios where that default mechanism might need a tweak, and to do so we are externalizing a way to input your own custom Weave script to change how the operations identifiers are generated. The important thing is that there are 3 bindings available for you to use:

[%header%autowidth.spread]
|===
|Binding name|Type|Description
|`operationId` | `String \| null` | identifier of the operation, might be null.
|`method` | `String` | HTTP method, not nullable.
|`path` | `String` | HTTP full path, not nullable.
|===

To do so, we will add a root `operationIdentifier` key to the descriptor file with the complete weave script. The following example is current default Weave script REST SDK is using

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operationIdentifier:
  expression: |
    #[%dw 2.0
    output text/plain
    ---
    operationId default (method ++ path)
    ]
----

This identifier is not only important in the Java class generation but also in the DSL and also the display name of a given operation, and because of that there will be cases in which it will make sense to change the default Weave script for the `operationIdentifier`.

Let’s assume that some API has dates and extensions in the resources, something that’s not useful to a consumer of the connector, and it comes without an `operationId` (either it’s empty in the OAS spec, or it’s a RAML spec), e.g.: `/2010-04-01/Accounts/{id}/Messages/SMS/Media.json`, both `/2010-04-01/` and `.json` are useless to the user, so we will need a Weave script like:

[source,yaml]
----
#% Rest Connector Descriptor 1.0
....
operationIdentifier:
  expression: |
    #[%dw 2.0
    output text/plain
    fun removeUnwantedStuff(aPath: String)=
        aPath replace ".json" with ""
          replace "/2010-04-01" with ""
    ---
    method ++ removeUnwantedStuff(path)
    ]
----

Which will take a resource like `/2010-04-01/Accounts/{id}/Messages/SMS/Media.json` leaving it as `/Accounts/{id}/Messages/SMS/Media` improving significantly the naming around the resource (for both XML DSL as well as the UI experience)


== Ignore Operations or Endpoints

If you don’t want to generate an operation in the connector for a
resource that is present in the API spec, you must use the `ignored`
property. You can define the ignored property at endpoint or operation
level.

If you ignore an endpoint, none of the operations defined under the
endpoint are generated.

If you ignore an operation, only that operation is not generated; the
rest of the operations for that endpoint are generated.

== Ignore an Operation

[source,yaml]
----
endpoints:
   /flights/{ID}:
      operations:
         delete:
            ignored: true
----

In this case, only the DELETE verb is ignored. Operations are still
generated for the other verbs in the resource.

[source,yaml]
----
endpoints:
   /flights/{ID}:
      ignored: true
----

In this case, all of the endpoint verbs will be ignored. No operations
will be generated for this resource.

== Ignore a Trigger

To ignore a trigger that was declared on a previous layer,
you can use the `ignored` property:

[source,yaml]
----
triggers:
   myTrigger:
     ignored: true
----

In this example, 'myTrigger' is ignored and will not be generated.


== Ignore Operations and Triggers by Default

All operations and triggers can be ignored using the `ignoreOperations` property at the root of the descriptor.

Set `ignoreOperations` to `true` to ignore previously declared operations and triggers. You can use this property to select only a small subset of operations and triggers for the connector to generate.

If an operation or trigger is ignored in a previous layer but `ignoreOperations` is set to `false`,
the operation or trigger will be generated in the connector.

If an operation or trigger is not ignored in a previous layer but `ignoreOperations` is set to `true`,
the operation or trigger will not be generated in the connector.

Using this property is similar to adding an `ignored` property to all of the operations and triggers.

[source,yaml]
----
#% Rest Connector Descriptor 1.0

ignoreOperations: true

endpoints:
   /flights/{ID}:
      ignored: false
----

In this example, only the operations under the `/flights/{ID}` path will be generated. All of the other operations and triggers will be ignored.


== Set a Display Name for Operations

You can define the display name of an operation by using the `displayName`
property in the operation node.

[source,yaml]
----
endpoints:
   /content_search:
      operations:
         get:
            pagination: content-search-pagination
            displayName: Get Content Search
            description: Provides keyword and refinement search functionality for content assets.
            outputMediaType: application/json
            expects:
               queryParameter:
                  count:
                     displayName: count
                     description: The maximum number of instances per request.
----

By setting this property, the operation is available to the final user
with the display name in the UI:

image::operation-display-name.png[]

If there happens to be an API in which you need to change the display name by comprehension rather than by extension, REST SDK provides a Weave script to delegate to. This is useful for those scenarios which there's a common pattern that wants to be removed from all displays names in a generic way.

REST SDK does provide a default script for the displays names, that tries to rely in the `operationId` if not null, or the conjunction of the `method` and the `path`.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
....
operationDisplayName:
  expression: |
        #[%dw 2.0
          output text/plain
          import * from connectivity::RestSdk
          ---
          displayNameFromOperationId(operationId)
            default displayNameFromMethodAndPath(method, path)
        ]
----

For further information about those 2 Weave functions, see the following link https://github.com/mulesoft/rest-sdk-all/blob/master/rest-sdk-connector-model/src/main/resources/connectivity/RestSdk.dwl[RestSdk.dwl]

But there are scenarios where that default mechanism might need a tweak, and to do so we are externalizing a way to input your own custom Weave script to change how the displays names are generated. The important thing is that there are 4 bindings available for you to use:

[%header%autowidth.spread]
|===
|Binding name|Type|Description
|`operationId` | `String \| null` | identifier of the operation, might be null.
|`method` | `String` | HTTP method, not nullable.
|`path` | `String` | HTTP full path, not nullable.
|`summary` | `String \| null` | the summary of the operation (matches with the summary in OAS), might be null.
|===

Let’s assume that some API has dates and extensions in the resources, something that’s not useful to a consumer of the connector, and it comes without an `operationId` (either it’s empty in the OAS spec, or it’s a RAML spec), e.g.: `/2010-04-01/Accounts/Messages/SMS/Media.json`, both `/2010-04-01/` and `.json` are useless to the user, so we will need a Weave script like:

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operationDisplayName:
  expression: |
    #[%dw 2.0
    output text/plain
    import * from dw::core::Strings
    fun removeUnwantedStuff(aPath: String)=
      aPath replace ".json" with ""
        replace "/2010-04-01" with ""
          replace "/" with " "
    ---
    capitalize(method) ++ removeUnwantedStuff(path)
    ]
----

Notice how we even didn't use the `operationId` as we know it will be null for this scenario.
And for and endpoint like `/2010-04-01/Accounts/Messages/SMS/Media.json` will generate a display name (assuming the `method` is `"POST"`) `"Post Accounts Messages SMS Media"`

Our Weave script library does contain helper functions, see https://github.com/mulesoft/rest-sdk-all/blob/master/rest-sdk-connector-model/src/main/resources/connectivity/RestSdk.dwl[RestSdk.dwl], that you could leverage into by importing it, for example:

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operationDisplayName:
  expression: |
    #[%dw 2.0
    output text/plain
    import * from connectivity::RestSdk
    fun removeUnwantedStuff(aPath: String)=
      aPath replace ".json" with ""
        replace "/2010-04-01" with ""
    ---
    displayNameFromMethodAndPath(method, removeTwilioStuff(path))
    ]
----

With the above Weave script, an endpoint like `/2010-04-01/Accounts/Messages/SMS/Media.json` with a `"POST"` `method` will generate the display name `"Create Accounts Messages SMS Media"`

== Set a Description for an Operation

You can define the description of an operation by using the
`description` property in the operation node.

[source,yaml]
----
endpoints:
   /content_search:
      operations:
         get:
            pagination: content-search-pagination
            displayName: Get Content Search
            description: Provides keyword and refinement search functionality for content assets.
            outputMediaType: application/json
            expects:
               queryParameter:
                  count:
                     displayName: count
                     description: The maximum number of instances per request.
----

The `description` property can be used to give the final user of the
connector some context or explanation of what the operation does. It
appears in Anypoint Studio as a tooltip.

image::operation-description-tooltip.png[]

[[select-default-media-type-for-an-operation]]
== Select a Default Media Type for an Operation

Both RAML and OAS API specs allow you to define multiple media types for
the operations.

REST SDK uses only one media type to generate the operation.

If it is not defined using a custom property, the default one is
selected following this priority:

* _application/json_ if it is defined
* _application/xml_ if it is defined
* The first media type defined in the API spec for that body

If you want to select the operation media type manually, you can use the
`inputMediaType` and `outputMediaType` properties. These properties
allow you to define the request body media type and the response media
type respectively.

[source,yaml]
----
endpoints:
   /content_search:
      operations:
         get:
            pagination: content-search-pagination
            displayName: Get Content Search
            description: Provides keyword and refinement search functionality for content assets.
            inputMediaType: application/json
            outputMediaType: application/json
            expects:
               queryParameter:
                  count:
                     displayName: count
                     description: The maximum number of instances per request.
----

== Select a Default Media Type for All Operations

If you want to select a default media type for your operations like
defined in xref:rest-sdk/configure-operations.adoc#select-default-media-type-for-an-operation[Select a Default Media Type for an Operation] but you want
to do it globally, you can use the `defaultInputMediaType` and
`defaultOutputMediaType` properties at the root level of the Connector
Descriptor.

[source,yaml]
----
defaultInputMediaType: application/json
defaultOutputMediaType: application/json

endpoints:
   /content_search:
      operations:
         get:
            pagination: content-search-pagination
            displayName: Get Content Search
            description: Provides keyword and refinement search functionality for content assets.
            expects:
               queryParameter:
                  count:
                     displayName: count
                     description: The maximum number of instances per request.
----

== Redefine an Operation Input/Output Type

The API spec may not define an input/output type; if you need one, you
can use the `inputType` and `outputType` properties in the Connector
Descriptor. You can set these properties at the operation level in the
connector descriptor. +
 +
For example, let’s say we have the following OAS spec.

[source,json5]
----
{
"paths": {
 "/payment_instrument/{payment_instrument_id}": {
   "post": {
     "responses": {
       "default": {
         "description": ""
       }
     }
   }
//[..]
}
----

In this case, the operation does not define input or output metadata. +
You can add it using the following descriptor:

[source,yaml]
----
defaultInputMediaType: application/json
defaultOutputMediaType: application/json

endpoints:
 /payment_instrument/{payment_instrument_id}:
   operations:
     post:
       inputType: './payment-instrument.json'
       outputType: './payment-instrument.json'
----

The operation uses the type definition from that schema as input and
output metadata. +
The value of this property must be the path to a JSON schema relative to
the location of the connector descriptor file. +
 +
In this case, the JSON schema appears as follows:

[source,json]
----
{
 "$schema": "http://json-schema.org/draft-04/schema#",
 "$ref": "#/definitions/PaymentInstrument",
 "definitions": {
   "PaymentInstrument": {
   "type": "object",
   "properties": {
     "name": {"type": "string"}
   },
   "required": [
     "name"
   ]
 }}
}
----

== Override an Operation Input/Output Type

You can also use the inputType and outputType properties to override the
type that is defined in the API spec. If a type is defined in the
connector descriptor, the one in the API spec is ignored.


== Skip Output Type Validations

`GET`, `POST`, `PATCH`, and `OPTIONS` operations defined in the API spec must declare a response body and a type for that body. If they do not, the connector descriptor must skip this check, define a response body for the operation, or declare it as void. +
+
Though is not the recommended approach, you can skip the this check using the `skipOutputTypeValidation` property in the connector descriptor.

It can be used at the operation level or globally.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
apiSpec:
  url: './api.raml'
connectorName: Version Manager
skipOutputTypeValidation: true           #<-- Global
endpoints:
  /endpoints/users:
    operations:
      get:
        skipOutputTypeValidation: true   #<-- Operation Level
----

If the validation is skipped, the generated connector still generates an `InputStream` output for the operation, and it contains the actual server response, but without informing the user that this operation has an output. This is not recommended and should be avoided as much as possible.

If the operation does not have an output, the `voidOperation` property should be used instead of this.

== Void Operations

`GET`, `POST`, `PATCH`, and `OPTIONS` operations defined in the API spec must declare a response body and a type for that body. If they don't, the connector descriptor must skip this check, define a response body for the operation, or declare it as void.

You can declare the operation as void using the `voidOperation` property of the operation node in the connector descriptor:

[source,yaml]
----
#% Rest Connector Descriptor 1.0
apiSpec:
 url: './api.raml'
connectorName: Version Manager
endpoints:
 /endpoints/void:
   operations:
     get:
       voidOperation: true   #<-- Operation Level
----

Using this property causes the operation to not have an `InputStream` as output. Instead, it always returns an empty string output. Using this property also causes the actual server response to be discarded. The HTTP response properties are still returned as attributes.
