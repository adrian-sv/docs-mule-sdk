= Testing Sources
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]


Apart from defining operations for your Module, you might want to define sources. Sources must be placed at the beginning
of a flow, therefore they can't appear directly in the test. When testing a source, you can have a flow with the source
you wish to test and then a test that hits or triggers it.
There are several types of sources, which also makes the testing strategies different for each of them

== Sources that emit a response

The simplest kind of test is when the source generates a synchronous response. In order to test this, you need to hit the
source to get that response and then assert it.

.Hit source that emits a response
[source, xml, linenums]
----
<flow name="responseSourceFlow">
    <test-connector:listener config-ref="aConfig" />
    <logger level="DEBUG" message="Listener executed"/>
</flow>

<munit:test name="responseSourceFlowTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="responseSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Hit the source -->
        <...>
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[payload]" expected="#['Example']"/>
    </munit:validation>
</munit:test>
----

TIP: For example, in the case of an `http:listener` you can hit the source with an `http:request`.

== Polling Sources

Since the polling source polls items periodically with a given `scheduling strategy`, the test needs to trigger the
polling source and wait for the next poll. Then, it can assert the response generated by the source.

=== Trigger a single time

.Trigger polling source once
[source, xml, linenums]
----
<flow name="pollingSourceFlow">
    <test-connector:polling-source>
        <scheduling-strategy>
            <fixed-frequency frequency="500"/>
        </scheduling-strategy>
    </test-connector:polling-source>
    <munit-tools:queue>
        <munit-tools:value>#[payload]</munit-tools:value>
    </munit-tools:queue>
</flow>

<munit:test name="pollingSourceTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="pollingSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Trigger the source -->
        <...>
        <!-- Wait for polling source to trigger -->
        <munit-tools:dequeue target="storedPayload"/>
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[vars.storedPayload]" expected="#['Example']"/>
    </munit:validation>
</munit:test>
----

TIP: For example, in the case of a `file:listener` you can trigger the source by creating new files.

=== Trigger multiple times

.Trigger polling source multiple times
[source, xml, linenums]
----
<flow name="pollingSourceFlow">
    <test-connector:polling-source>
        <scheduling-strategy>
            <fixed-frequency frequency="500"/>
        </scheduling-strategy>
    </test-connector:polling-source>
    <munit-tools:queue>
        <munit-tools:value>#[payload]</munit-tools:value>
    </munit-tools:queue>
</flow>

<munit:test name="pollingSourceTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="pollingSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Trigger the source -->
        <...>
        <!-- Wait for polling source to trigger -->
        <until-successful maxRetries="10" millisBetweenRetries="100">
            <munit-tools:assert-that expression="#[MunitTools::queueSize()]" is="#[MunitTools::equalTo(5)]"/>
        </until-successful>
    </munit:execution>
    <munit:validation>
        <!-- Assert payload -->
        <foreach collection="#[1 to 5]">
            <munit-tools:dequeue target="storedPayload"/>
            <munit-tools:assert-equals actual="#[vars.storedPayload]" expected="#['Example']"/>
        </foreach>
    </munit:validation>
</munit:test>
----