= Mule SDK Development Best Practices
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The purpose of this documentation is to provide users of the Mule SDK with best practices for building modules and connectors in a way that makes the best use of Mule runtime engine (Mule) functionality and is consistent with MuleSoft’s UX and quality guidelines.

=== Terminology

This documentation uses these special terms:

Connector::
A module that establishes connections to an external system. A connector is a module.

Large String::
A String larger than 4 KB in size.

Module::
A plugin built through the Mule SDK that extends the functionality of Mule 4.

Mule language::
The XML-based domain-specific language (DSL) used to write Mule applications and through which a module is used inside an operation.

Must::
The word "must" denotes a hard rule. This means that to be considered compliant with best practices, a module has to comply with all the practices described with this term.

Should::
This word "should" denotes a rule that, although recommended, could be skipped in certain cases and the module would still be compliant with best practices.

Target system::
The resource that a connector accesses.

User::
This refers not to the user of the Mule SDK (the one coding the module), but to the end user who consumes the module that a developer produces. All best practices are ultimately aimed at improving the end user’s experience.

== MuleSoft Coding Practices

Using the SDK to create a new module or connector *should not* be approached as simply wrapping an API, library, or piece of functionality into a component that Mule can understand.

Instead, the problem *should* be approached as “extending a programming language called Mule.”

If you were to create a new library for the C programming language or your own Java framework, you would design library APIs, syntax, and semantics so that a C or Java developer consuming that library finds it consistent and compliant with all the rules and guidelines inherent to that ecosystem. Failing to do so results in unhappy consumers with unmet expectations for consistency and clarity.

The same applies to a custom Mule module or connector, which needs to be approached not as just creating a Mule bridge, but as an extension to the Mule language that provides additional functionality in a consistent, usable, and organic way.

== General Coding Rules

This set of general rules applies to any component of a module or connector. These apply on all operations, sources, configs, connection providers, and functions).

=== Connectors Must Closely Reflect the Target System

In the context of Anypoint Platform, a connector’s purpose is to bring the target system into the Mule language. The connector *must not* add higher-level abstractions or include operations that implement specific business use cases.

For example, imagine a billing API that contains resources for creating an invoice, adding items to an invoice, and submitting an invoice. The connector for such an API *must* contain one operation per each of those resources, but *must not* include an operation that combines all three calls into a single unit.

The one exception is auto-paging operations, which, to achieve the paging effect, perform several calls as part of processing the output of one single Mule operation.

=== Do Not Mix Protocols

One connector *must* connect to only one type of protocol at a time. For example, suppose an external system exposes a REST API, a SOAP API, and an OData API.

In Anypoint Platform, there are three different APIs, even if they access the same external system. Therefore, each 
of those APIs *must* have its own connector, instead of one that understands the three protocols.

=== Exported Module Java API

Before reading this section, see xref:mule-sdk::isolation.adoc[Classloading isolation] in the Mule SDK.

The module *must* export only packages defined in your module. Packages from dependency libraries *must not* be exported.

==== Java Packages
	

Packages from the JDK are treated differently since modules don’t export them but only consume them. Mule automatically exports all available Java packages for the modules to use. 

However, the module *must* use only Java packages available on all of the JDKs supported by the Mule versions that the module is compatible with. Vendor-specific packages such as com.sun *must not* be used.

==== Java 11 Compatibility

Starting with Mule 4.2.0, JDK 11 is also supported. That means that when depending on native Java APIs, the module *must* account for the fact that the needed API might not be available given Java’s new modular architecture (also known as https://openjdk.java.net/projects/jigsaw/[Project Jigsaw], first introduced in Java 9).

For example, if your module requires the Java Transaction API (JTA), the module *must* declare the following dependency in its pom.xml file:

[source,xml,linenums]
----
<dependency>
  <groupId>javax.transaction</groupId>
  <artifactId>javax.transaction-api</artifactId>
  <version>1.2</version>
</dependency>
----

Or if the Java Mail API is used:

[source,xml,linenums]
----
<dependency>
  <groupId>javax.mail</groupId>
  <artifactId>javax.mail-api</artifactId>
  <version>1.6.2</version>
</dependency>
----

=== Design for Thread Safety

Mule is a reactive execution engine, designed for highly concurrent workloads. Therefore, all components *must* always be designed to support concurrent executions at minimal contention.

https://en.wikipedia.org/wiki/Thread_safety[Thread safety] is a basic concept for any Java developer familiar with concurrency. Users of the SDK are expected to be familiar with this. 

=== Use Immutable Payload and Attributes Objects 

All output types, used as either payload or message attributes, *must* be immutable objects.

=== Correct Use of Content Parameters

Make correct use of @Content parameters according to the MuleSoft xref:mule-sdk::content-parameters.adoc[Content Parameters] document.

=== Never Access Flow Variables

In Mule 4, variables are for exclusive access of end users only. No module *should* ever access flow variables directly. 

Although the SDK doesn’t provide any API for accessing them, optional parameters can be leveraged to hack this restriction. For example:

[source,java,linenums]
----
@Optional(defaultValue = "#[vars.foo]") String foo

@Optional(defaultValue = "#[vars]") Map<String, TypedValue<Object>> vars
----

However, these statements (or any other way of getting to the vars from inside a module) are forbidden. Every piece of information required by the module *should* be made explicit through a parameter. End users decide to assign that value to a variable or not. 

Notice that violating this rule automatically violates position independence.

=== Never Use Message Attributes as Parameters

No component *should* define a parameter of a type that’s also used as message attributes, even if the attributes object is defined as part of the same module.

For example, if a connector has an operation that uses the LocalFileAttributes class as output attributes, the following is illegal:

[source,java,linenums]
----
public void checkAccess(@Content LocalFileAttributes attributes) {
        doCheckAccess(attributes);
}
----	

Instead, add parameters that reflect what information from the attributes class you actually need:

[source,java,linenums]
----
public void checkAccess(String path) {
 ...
}
----	

=== Use Correct Encodings

When connecting to systems that accept multiple encodings, the encoding to be used *must* be configurable through a xref:mule-sdk::config-override.adoc[Configuration Override]. This means that the encoding to use *should* be parameterizable at the config level, but also on each component that requires it (operations, sources, functions, and so on).

At the config level, the encoding parameter *must* default to the Mule default encoding, which is obtained through the @DefaultEncoding annotation.

For example:

[source,java,linenums]
----
public class MyConfig implements Initialisable {
        
        @DefaultEncoding
        private String defaultEncoding;

        @Parameter
        @Optional
        private String encoding;

        public void initialise() throws InitialisationException {
                if (encoding == null) {
                        encoding = defaultEncoding;
                }
        }

        public String getEncoding() {
                return encoding;
        }

}
----	

=== Duration Parameters

Modules often require that you configure durations with classical examples such as timeouts and cache evictions.

Durations *must* be expressed as the combination of two parameters:

* An int or Integer scalar parameter with the Timeout suffix
* A java.util.concurrent.TimeUnit parameter that qualifies the scalar 
+
This parameter *must* be named exactly the same as its companion scalar except for adding the TimeUnit suffix. The TimeUnit parameter *should* default to SECONDS.

For example:

[source,java,linenums]
----
/**
* The socket connection timeout value. This attribute works in tandem with {@link #connectionTimeoutUnit}.
*/
@Parameter
@Optional(defaultValue = "5")
@Placement(tab = ADVANCED_TAB, order = 1)
@Summary("Socket connection timeout value")
private int connectionTimeout;

/**
* A {@link TimeUnit} that qualifies the {@link #connectionTimeout}
*/

@Parameter
@Optional(defaultValue = "SECONDS")
@Placement(tab = ADVANCED_TAB, order = 2)
@Summary("Time unit to be used in the Timeout configurations")
private TimeUnit connectionTimeoutUnit;
----

=== Timeouts Must Have Configurable Configuration Overrides

All components that perform operations that could be affected by timeouts *must* make those configurable through xref:mule-sdk::config-override.adoc[Configuration Override] parameters.

Such timeouts *must* be expressed as duration parameters.

=== Only Primary @Content Should Default to Payload

No parameter other than a primary content *should* default to payload. This means that the following *should* never be used:

[source,java]
----
@Optional(defaultValue = "#[payload]")
----

=== Handle Dates and Time Parameters

Date and time parameters *must* be implemented by using java.time.LocalDate or java.time.LocalDateTime types. Do not use java.util.Date or java.util.Calendar.

=== Check the End-to-End Experience

Before publishing your module, test it in Anypoint Studio and Anypoint Design Center. Make sure it provides good usability and a good experience. A module that works but is hard to use is not complete.

You *must* check for the following: 

* DataSense is correctly resolved for all input parameters and output values.
* Each component's parameter <<layout>> is correct.
* No typos exist in labels and descriptions.
* Users can easily build an application that uses the module’s main use cases.

=== Discourage the Use of POJOs

The SDK allows using POJOs as both input parameters and output types. However, their use  is discouraged. All modules *should* make a best effort to use JSON or XML instead. In the case of dynamic types, Java Maps may also be used. 

This rule doesn’t mean that there’s no use case for using POJOs, nor that you need to convert all structures to JSON or Java Maps. This rule is merely about favoring data formats that interoperate better with other components and avoid serialization issues.

For example, suppose that your organization developed a Java taxes library that you want to leverage in your Mule applications. If this library returns POJOs, it is okay for you to build an SDK module that wraps this library, even if that means that this tax module will accept and produce POJOs.

Instead, if what you are leveraging is a Tax API that returns JSON, then your Tax connector *should* return the same JSON as the API instead of transforming that JSON into a POJO.

=== Expose POJOs

All POJOs that are exposed (because they’re being used as output types, input parameters, or message attributes) *must* be DataWeave compliant. This means that all  have a default constructor and a getter method for each @Parameter annotated field.

=== User Must Not Be Aware of Java Types

The user *must not* need to know the Java type used to implement a module in order to use it. 

For example, consider the following transformation:

[source,json,linenums]
----
{
  name: "Pedro",
  address: {
           x: 11,
         y: 12
  }
}  as com.foo.Person
----

The module *must* be defined in a way in which explicit transformations such as this are not needed. Some ways of achieving this are:

* Don’t use POJOs to represent a person (recommended)
* Make com.foo.Person a DataWeave compliant concrete class
* When used as an input parameter, refer to com.foo.Person explicitly instead of using an abstract type or interface

=== Payload and Attributes Must Be Serializable

Message attributes objects returned by either operations or message sources *must* be Java Serializable. Otherwise they cannot be used  with ObjectStore, VM queues, or Mule in cluster mode.

=== Don’t Access the MuleContext

The MuleContext is deprecated and *must not* be accessed by any module or connector.

Most of the time, the only reason for a module to access the MuleContext is to obtain certain Runtime service. For example:

[source,java]
----
muleContext.getRegistry().lookupByType(ObjectStoreManager.class)
----	

Instead, use @Inject to obtain those services.

[source,java,linenums]
----
public class MyComponent {

@Inject
ObjectStoreManager osm;
}
----

=== Log Through SLF4J

All logging *must* be made through the SLF4J API.

The module *must not* add any dependency with this API as it’s already provided in the parent pom file provided by MuleSoft.

=== All Loggers Must Be Static

Loggers are expensive to create. Therefore, all loggers *must* be private, static, and final.

For example:

[source,java,linenums]
----
public class Operation {
        
        private static final Logger LOGGER = LoggerFactory.getLogger(Operation.class);

        ...
        
}
----	

=== Avoid Static State

All module classes *must not* contain a static state. The only exceptions are Loggers and the serialVersionUID of Serializable classes.

=== Choose the SDK Version

Normally, developers tend to use the latest available version of any given product. This *should not* be the case with the SDK. To extend Mule, you should:

* Identify the features you need
* Choose the lower version that includes the features you need.

For more on selecting the correct SDK version, see xref:mule-sdk::choosing-version.adoc[Choosing the SDK Version].

=== Do Not Use Boxed Booleans

Boolean parameters *must* be of the native boolean type. A boxed Boolean is not allowed as a parameter type.

All boolean parameters are considered optional and *must* default to false. You can use the @Optional annotation to change the default of a boolean, but you can never make it a required parameter.

=== Use Plural Names for List Parameters

All parameters implemented as a Java Collection, Map, or Array, or any other type that represents an array of some sort, such as a JSON array, *must* have a plural name.

=== Use Semver Versioning

Modules *must* be versioned using the https://semver.org/[Semantic Versioning] standard.

=== Use Strict Camel Casing

The entirety of the module’s source code *must* correctly apply camel casing. This is critical since otherwise the SDK will not be able to correctly generate the XML DSL or process layouts.

== Define Configurations and Connection Providers

=== Distributing Parameters 

One key aspect is determining which parameters *should* be part of a configuration object and which *should* be part of a configuration provider.

Connection providers *must* contain only parameters that are used to establish and configure connections to an external system. Any parameters used for any other purpose *must* go into the configuration object instead.

=== POJO Parameters in Configurations 

When a configuration or connection provider uses a POJO as a parameter type, without the use of the @ParameterGroup annotation, then the POJO *must* comply with the following:

* Have a default constructor
* Expose a getter for each field annotated with @Parameter
* Override the equals() and hashCode() methods with an implementation that uses all the @Parameter fields

=== Don’t Establish Connections During the Lifecycle Phase

ConnectionProviders can hook into the application lifecycle by implementing any of the corresponding interfaces (Initialisable, Startable, Stoppable, or Disposable).

Connections *must not* be established in the initialisable() or start() methods, and they *must not* be disconnected during the stop() or dispose() methods. Therefore, the provider’s constructor and lifecycle methods *must* never throw a ConnectionException.

Connections *must*  be established only in the connect() method and *must* be severed only in the disconnect(T) methods

=== Handling SSL Connections

When a connector needs to establish a TLS/SSL secure connection, the SSLContext *must* be obtained through a TlsContextFactory parameter as explained in this article.

When a ConnectionProvider has a TlsContextFactory parameter, it *must* also implement the Initialisable interface and invoke the initialise() method on such context during initialization:

[source,java,linenums]
----
public class MyConnectionProvider implements ConnectionProvider<Connection>, Initialisable {
        
        @Parameter
        private TlsContextFactory tlsContext;

        @Override
        public void initialise() throws InitialisationException {
                ((Initialisable) tlsContextFactory).initialise();
        }
}
----	


=== Defining a Connection Management Strategy

When defining  or designing the xref:mule-sdk::connections.adoc[connection management strategy], the following decision process *must* be followed:

* The most efficient option is to use a CachedConnectionProvider.
+
This however requires that the connection object *must* be thread safe, and that thread safeness *must not* come at the expense of significant synchronization contention.
+
* If a CachedConnectionProvider is not possible, then a PoolingConnectionProvider *should* be used instead, especially if establishing the connection is expensive.
* Only if neither of the previous two options  are possible, *should* a plain ConnectionProvider be considered.

=== Handling OAuth Protected Connections

The SDK supports building connectors to systems protected by OAuth. xref:mule-sdk::oauth.adoc[As explained in this article], it automatically handles the process of obtaining and refreshing OAuth tokens, which are made available through an AuthorizationCodeState object (if the Authorization Code grant type is being used) or the ClientCredentialsState object (if the Client Credentials Grant Type is being used).

The sections that follow provide additional considerations for OAuth use.

==== Handle Token Expiration

Although the SDK provides the ability to refresh access tokens in a thread-safe manner, there’s no standard way to detect that the token has actually expired because different service providers communicate this in different ways, making it each connector’s responsibility to detect such a condition. 

When using OAuth authentication, all connectors *must* detect when a token has expired and communicate it to Mule by raising an AccessTokenExpired exception.

This is difficult because connectors *must* differentiate between the following conditions:

* The access token expired and needs to be refreshed
* The access token is valid, but lacks privileges to perform a given action
* The access token has been remotely revoked

==== Always Query the State Object on Each Request

The AuthorizationCodeState and ClientCredentialsState objects are the means through which connectors gain access to the access tokens that Mule manages. Most precisely, this happens through the getAccessToken() method that both classes share.

Because of the highly concurrent nature of Mule, those tokens can be refreshed or unauthorized at any time.

Therefore, the getAccessToken() method *must* be invoked on the state object for every request to be sent. The access token *must not* be cached or stored in an internal variable.

This consideration is especially important when using third-party client libraries that might perform caching.

=== Connection Object Must Not Expose (Nor Be) the Inner Client

A common anti-pattern often found in connectors is that the ConnectionProvider generates a connection object that exposes the client or implementation used to access the external system. For example:

[source,java,linenums]
----
public class HttpConnection {
        
        private HttpClient client;

        public HttpClient getClient() {
                return client;
        }
}
----	

An operation would then use it like in this pseudo code:

[source,java,linenums]
----
public void createCustomer(@Connection HttpConnection connection, @Content InputStream content) {
        
        connection.getClient().send(HttpRequest.builder()
                .path(connection.getPath() + "/customer")
                .method("POST")
                .entity(content)
                .addHeader("Accept", "application/json")
            .build()
        );
}
----	

This code has several drawbacks. The most obvious is that the operations using the connection are strongly coupled to the implementation of the connection object. If the need ever comes to change the implementation of the client, all the components using that connection will be affected.

Another problem is that the connection object is not testable. Because the client object is exposed, writing a test that interacts with a mock version of the connection object becomes too complicated.

The biggest problem is that it introduces functional coupling between all components using the connection object and the functional nuances of all supported connection providers.

For example, assume that the example above is part of a connector that supports both Basic Authentication and OAuth authorization mechanisms.

If invalid credentials are used with the Basic Authentication connection, then the request will result in a HTTP 401 status code and the operation *should* fail. 

However, if the same response code is received using an OAuth protected connection, then the connector needs to execute logic to determine if the token has expired and an AccessTokenExpiredException *should* be thrown.

As new connection types and components are added, the worse the problem becomes. This is only one example. It can happen with all other types of connections, not just HTTP clients.

To prevent this, the connection objects *must* encapsulate their inner communication mechanisms and security schemes, leading to a pattern like this:

[source,java,linenums]
----
public void createCustomer(@Connection HttpConnection connection, @Content InputStream content) {
        
        connection.createCustomer(content);
}
----	

With this approach, each ConnectionProvider implementation can provide its own implementation of the HttpConnection object, removing the root cause of the problem and providing freedom to change the inner workings of the connection without affecting other components.

==== Alternative: Leverage the Command Pattern

Instead of giving the connection object one method per endpoint to be consumed, another option is to implement the command design pattern in a more generic way:

[source,java,linenums]
----
public void createCustomer(@Connection HttpConnection connection, @Content InputStream content) {
        
        connection.request(HttpRequest.builder()
                .path(connection.getPath() + "/customer")
                .method("POST")
                .entity(content)
        );
}
----

With this approach, the connection object has only one generic request method which receives an HttpRequestBuilder object. Notice that the builder object never receives the build() command. Depending on the implementation of the connection object, additional headers can be added, the request can be performed in different ways and the response can be processed accordingly.

=== Do Not Export as Part of the Module’s API

Configuration, ConnectionProvider and Connection classes *must not* be exported as part of the module’s API.

== Defining Operations

The sections that follow provide general rules that apply to all operations.

=== Position Independence

Operations *must not* depend on their position in the flow for them to work.

This means that no component *should* depend on the side effects of a prior or next component to fulfil its contract.

For example, consider the following flow:

[source,xml,linenums]
----
<flow name="independence">
  <my-connector:operation-a />
  <my-connector:operation-b />
</flow>
----	

`<operation-b>` *must not* depend on `<operation-a>` to have been previously executed for it to work. 

=== Non-Metadata Key Parameters Must Not Change the Output Type

Behavior parameters *must not* change the operation’s return type. 

NOTE: There’s a special case regarding parameters that act as Metadata Keys. This rule applies to all non-metadata key parameters. For example, a module wants to offer the capability to perform a given action both synchronously (which means that the output results are available immediately) or asynchronously (the operation returns a promise ID that can be later be used to retrieve the result). 

This could be solved like this:

[source,xml,linenums]
----
<fruits:get-apple async="false"/>
<fruits:get-apple async="true"/>
----	

The first operation returns an apple object, and the second returns a String representing a job ID.

This example is illegal. The get-apple operation *must* always return an apple. It cannot change its return type based on the async parameter.

This *should* be modeled as two different operations:

[source,xml,linenums]
----
<fruits:get-apple />
<fruits:get-apple-async />
----

=== Dynamic Types and Metadata Key Parameters

Metadata Key parameters are treated as special because they are allowed to change the output type of an operation. This change can be considered in two levels:

* The operation still always returns an apple, but the definition of what an apple is changes dependending to the system instance or user that is being used (even if the structure of the apple is dynamic, it’s still an apple)
* The operation is generic and the Metadata Key parameters actually determine which type will be returned.

For example:

[source,xml]
----
<my-connector:search searchType="ORDERS" query="......" />
----

This operation does not violate the rule that the non-metadata key parameters *must not* change the output type because:

* This operation returns a List, even if the type of the items in that list depends on the searchType parameter
* searchType is set to “ORDERS”, it always returns a list of ORDERS. There’s no other parameter in the operation that makes it return a list of ORDER_REFERENCES instead.

== Operation Output

The output of operations *must* comply with the following:

=== Always Communicate the MIME Type

For DataWeave to handle the output of an operation, it is critical to make sure that the MIME type of the output value is always communicated. 

The SDK does this automatically when the return type is a Map, POJO, or Java simple type (String, Integer, Short, and so on).

However, when the output type is a String, InputStream, or byte[], the module *must* specify the mimeType for that value. Otherwise DataWeave will not know how to handle it.

There are two ways of doing this:

* @MediaType annotation
+
When the output type of the operation is always certain, the @MediaType annotation *must* be used:
+
[source,java,linenums]
----
@MediaType("application/json")
public InputStream getPerson(String personId) {
// ....
}
----	
+
* Use the Result object
+
There are other cases in which the return MIME type is known only at runtime. Examples of this include:
+
** Reading a file (the actual MIME type depends on the file being read) 
** Hitting an HTTP endpoint that accepts several MIME types (the server communicates the MIME type through the Content-Type header).
+
For example:
+
[source,java,linenums]
----
public Result<InputStream, FileAttributes> read(String path) {
        return Result.<InputStream, FileAttributes>builder()
         .output(readStream(path))
         .mediaType(inferMediaTypeFromFileName(path))
         .attributes(getAttributes(path))
         .build();
}
----
+
* Using Java POJOs as return types
+
If the operation returns a POJO, then:
+
** The class *must* be part of the module’s API.
** The object *must* be a value object that cannot contain any logic.
** The object *must not* contain any static state.
** The object *must* be Serializable.
+
* Handling JSON and XML output types
+
Some operations return values in the form of JSON or XML documents. 
+
** Java Types
+
The JSON and XML documents *must* be returned in the form of an InputStream. None of the usual Java types for representing these types (Reader, Sax objects, Document, Node, JSON Node, and so on) are allowed.
+
** DataSense Resolution
+
For tooling to assist the user with handling the documents returned by the operation, the schema of the returned documents needs to be known. Therefore, operations *must* clearly define the output schema.
+
*** Static DataSense
+
Sometimes, the schema is fixed and well known. If the schema is well known and static, the problem *must not* be resolved through the use of dynamic DataSense resolvers. The connector *must* specify that schema through either of the following instead:
+
**** @OutputJsonType
+
Define the output type by pointing to a JSON schema that's part of a module's resources:
+
[source,java,linenums]
----
@OutputJsonType(schema = "person-schema.json")
public InputStream getPerson(String personId) {
   // ...
}
----
+
**** @OutputXmlType
+
Similar to @OutputJsonType, but for XML schemas:
+
[source,java,linenums]
----
@OutputXmlType(schema = "order.xsd", qname = "shiporder")
public void getOrder(String orderId) {
...
}
----
+
**** OutputStaticTypeResolver
+
Define the type programmatically.
+
[source,java,linenums]
----
@OutputResolver(OrderTypeResolver.class)
public InputStream getOrder(String orderId) {
...
}
----

=== Dynamic DataSense

If the schemas are dynamic, a dynamic output resolver is needed. This is done by implementing the OutputTypeResolver interface. 

The key rule is that the module *must* resolve to a specific schema that the user can abide by. The dynamic resolver cannot return a generic ANY type.

[source,java,linenums]
----
@OutputResolver(DynamicOrderTypeResolver.class)
public InputStream getOrder(String orderId) {
...
}
----

=== Dynamic Java Type Parameters

It’s very common for connectors to handle dynamic types. For example, services like Salesforce, NetSuite, or SAP define a set of core entities (Person, Order, and so on) that have a base structure that the user can customize.

Other services go further and allow for a completely custom type set, for example, any OData service.

All operations returning these dynamic types *must* have an associated @OutputTypeResolver that provides the actual type definition to be used for the current configuration.

Prior sections discussed this for output values communicated in the form of JSON or XML documents. The same applies for parameters represented as Java types, such as Map or custom POJOs. A well defined, non trivial OutputTypeResolver *must* exist for all other dynamic types, regardless of which Java class is being used to represent them.

=== Streaming

=== Favor InputStream over byte[]

InputStream *should* be used as a return type instead of a byte[] array. Returning an array of bytes is valid when such array is certain to be of a small size. 

If the array size is unknown, variable or potentially large, then the operation *must* return InputStream.

This avoids large memory requirements that can lead to an OutOfMemoryError, especially when running in small workers. Returning InputStream implies that your code needs to avoid fully loading that large piece of information into memory. Loading the entire byte[] array into memory and only wrapping it into a ByteArrayInputStream completely defeats the purpose of this rule and *must* be avoided.

=== Don’t Return Large Strings

Returning a String is acceptable, but only if you can ensure that the string does not become a String larger than 4 KB. If that’s a possibility, then the operation *must* return InputStream instead, and use @OutputResolver to provide metadata on the expected media type.

=== Use the StreamingHelper

When a component returns a streamable resource (InputStream or PagingProvider), the SDK automatically makes those streams repeatable (provided that the application is configured to do so).

When those resources are contained in a higher level structure such as a Map, you *must* use http://www.mulesoft.org/docs/site/4.1.1/apidocs/org/mule/runtime/extension/api/runtime/streaming/StreamingHelper.html[StreamingHelper] to explicitly tell the SDK to perform that adaptation. 

Common cases:

* Stream contained inside a Map
+
An example of this case is the <db:select> operation, in which the result set obtained from the database is returned in the form of a Map for which the keys are the column names and the values are the actual result. If the result set contains a BLOB column, then that value is of type InputStream. For that case, the connector *must* use this method, which returns a new Map in which all streamable resources have been made repeatable:
+
`org.mule.runtime.extension.api.runtime.streaming.StreamingHelper#resolveCursors(Map, boolean)`
+
* Stream contained in a POJO
+
Although not applicable for the case of database, it is possible to have a use case in which InputStream is actually contained in a field of a POJOo. 
+
In the previous case, `<db:select>` returns a Map because the actual structure of the response is unknown, as it changes with each query. Ensure you plan ahead to avoid causing problems that require difficult troubleshooting.
+
However, if you’re using a POJO, it’s because the structure is fixed, which means that the POJO most likely contains some well-known attributes and some streamable information. Although we cannot 100% ensure it , most likely the fixed attributes of that POJO *should* go into an Attributes object and the stream into the payload, reducing this to the standard case.
+
On the corner case in which doing this actually makes sense, the field containing the streaming resource *must* be adapted using the org.mule.runtime.extension.api.runtime.streaming.StreamingHelper#resolveCursorProvider(Object) method.
+
NOTE: Although the pattern of a POJO containing a streamable resource is not explicitly forbidden, it is a big code smell that *should* be reviewed carefully and *must* be matched with a custom Metadata resolver. 
+
Assuming that the scenario is valid, a custom Metadata resolver is necessary because you don’t know if the value will be adapted into a CursorProvider or not. It will have to be of type Object, which means it will become obscure to DataSense without the aid of a custom resolver. 

=== Favor Non-Blocking I/O

Mule 4 is a reactive execution engine that is optimized to perform non-blocking I/O operations.

When an input or output operation executes in non-blocking mode, the connector *must* adhere to the MuleSoft xref:mule-sdk::non-blocking-operations.adoc[Non-Blocking Operations] requirements.

Best uses for non-blocking I/O:

* Accessing files in the local file system
* HTTP requests
* TCP/UDP socket requests
* Any I/O operation for which a non-blocking client exists

Where not to use non-blocking I/O:

* Accessing a database through JDBC (non-blocking JDBC drivers are still experimental)
* Using clients where non-blocking equivalents do not exist or are unreliable, such as using Apache Commons Net for accessing FTP servers where no reliable non-blocking option exists. 

==== Non-Blocking and Asynchronous Are Not the Same 

It’s common to confuse asynchronous with non-blocking. They are not the same thing. This rule of favoring non-locking I/O does not mean that all I/O operations *should* be dispatched to a separate thread that is executed asynchronously just for the sake of it.

Be sure you have a good understanding of the principles of non-blocking IO and how it's implemented in Mule. 

See:

* http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking[The Difference Between Asynchronous and Non-Blocking]
* xref:mule-sdk::non-blocking-operations.adoc[Mule Non-Blocking Operations]

=== Use Transactions

When an operation interacts with a transactional system (including XA transactions), the operation *must* support that capability. See Transactions.

== Defining Parameters

Defining parameters well is a key aspect of the usability of any component. Even if the components provides awesome functionality, the user is not going to have a great experience if the component is not easy and intuitive to configure. 
Handling JSON and XML Parameters

Some operations expose parameters that expect values in the form of JSON or XML documents. 

* Java types
+
The JSON and XML parameters *must* be received in the form of an InputStream. None of the usual Java types for representing these types (Reader, Sax objects, Document, Node, JsonNode, and so on) are allowed.
+
* DataSense resolution
+
Users need tooling support to make sure that they feed these parameters with documents that conformed to the expected schemas. Therefore, these parameters *must* clearly define the expected schema.
+
** Static DataSense
+
Sometimes, the schema is fixed and well known. If the schema is well known and static, the problem *must not* be resolved through the use of dynamic DataSense resolvers. The connector *must* specify that schema through either of the following instead:
+
*** @InputJsonType annotation
+
Allows you to define the expected type by pointing to a JSON schema that’s part of the module’s resources:
+
[source,java,linenums]
----
public void createPerson(@InputJsonType(schema = "person-schema.json") @Content InputStream person) {
...
}
----	
+
*** @InputXmlType annotation
+
Similar to @InputJsonType, but for XML schemas:
+
[source,java,linenums]
----
public void createOrder(@InputXmlType(schema = "order.xsd", qname = "shiporder") @Content InputStream order) {
...
}
----
+
*** InputStaticTypeResolver
+
Another option is the use of an InputStaticTypeResolver to define the type programmatically:
+
[source,java,linenums]
----
public void createOrder(@TypeResolver(OrderTypeResolver.class) @Content InputStream order) {
...
}
----	
+
More information about xref:mule-sdk::static-metadata.adoc[handling static DataSense].
+
** Dynamic DataSense
+
If the schemas are dynamic, then a dynamic resolver is needed. This is done by implementing the InputTypeResolver interface. 
+
The key rule is that the module *must* resolve to a specific schema that the user can follow. The dynamic resolver cannot return a generic ANY type.
+
[source,java,linenums]
----
public void createOrder(@TypeResolver(DynamicOrderTypeResolver.class) @Content InputStream order) {
...
}
----

=== Dynamic Java Type Parameters

It’s very common for connectors to work with dynamic types. For example, services like Salesforce, NetSuite, or SAP define a set of core entities (Person, Order, and so on) which have a base structure that the user can customize.

Other services go further and allow for a completely custom type set, such as an  OData service.

All parameters using these dynamic types *must* have an associated @TypeResolver that provides the actual type definition to be used for the current configuration.

Prior sections discussed the need for @TypeResolver for parameters communicated in the form of JSON or XML documents. The same applies for parameters represented as Java types, such as Map or custom POJOs. A well defined, non-trivial TypeResolver *must* exist for all other dynamic types, regardless of which Java class is used to represent them.

=== Streaming

Streaming is a key aspect of Mule 4. It’s important to define operations in a way that allows to leverage that.

* Don’t use byte[] array parameters
+
Parameters *must not* be of byte[] type. Use InputStream instead. Mule automatically transforms any byte[] parameter value into an InputStream.
+
* Avoid large String parameters
+
String parameters are perfectly fine, but always consider what are the odds of the assigned values to become larger than 4 KB. If that’s a possibility, then the parameter *must* be an InputStream instead and use an InputTypeResolver to provide metadata on the media type that’s expected.

[[layout]]
=== Layout

The MuleSoft layout mechanism comprises two organizational concepts: groups and tabs. 

Although you are free to define your own groups and tabs, there’s a set of standard names for them.

Default groups:

* General
* Advanced
* Connection

Default tabs:

* Default
* Advanced
* Security
* Connection

If a given parameter does not fit these categories, define a new one that can be defined. That decision needs to be made explicit and documented in the extension’s design spec.

* Required Parameters
+
Required parameters *must* always be in the default group and tab, and *must* be the first to appear in the generated UI.
+
Required parameters *must* be placed on the main group and tabs so that the end user can see at all of them at first glance.
+
* Optional Parameters
+
Optional parameters *should not* be placed in the main view. This is to not overload the view with too much content that in most cases won’t be configured by the average customer.
+
Exceptions:
+
** Some optional parameters are not required to be configured, but are used very frequently.
** The parameter is optional because it has a default value, but it’s still key to the component’s behavior (for example, the method parameter of the http:request operation).
** Default Values
+
Expressions *should* never be used as default values. This includes expressions that access the event (such as `#[vars]`, `#[attributes]`, or `#[payload]`), and expressions that obtain dynamic values (such as `#[now()]`) or create default empty structures (such as `#[[]]`).
+
* @NullSafe
+
Optional parameters of Collection or Map types *must* be annotated with @NullSafe to guarantee that null values are avoided by automatically providing empty instances instead.
+
* Security parameters
+
When talking about security parameters, it’s important to distinguish between actual security parameters and connection parameters. For example, username and password could be thought of as security parameters because they’re used for access control. But in reality, you can’t establish a connection without those in the first place, so they are also required connection parameters.
+
** Therefore, optional security parameters like tlsContext, or hashing algorithms *must* go into a security tab, except when they are required.
** Required security parameters, *must* go in general as any other required parameter.
+
* Parameter ordering
+
As explained earlier, required parameters *must* also be shown first, but in which order *should* they be listed? The same thing applies to optional parameters: we know they go after the required ones, but in which order? 
+
Parameter ordering considerations:
+
** There’s a strong and known relevance ranking
+
In some cases, the developer knows that some parameters are more relevant than others. That relevance might be given based on how frequently they are used or by how relevant they are to the particular domain of the connector. For example: when talking about the http:listener, the path is by far the most relevant parameter, even if other required parameters exist. The same applies to the optional parameters: the allowed-methods parameter is more relevant than the keep alive settings.
+
The problem with this case is that relevance might be subjectively biases. People might not agree on what’s relevant or not and the person making the call could simply be wrong. In these cases, the case for that relevance sorting *must* be made explicit in the extension’s design document and justified. Reviewers *must* also have the chance to challenge that decision.
+
** Metadata Keys order: 
+
This scenario applies only for operations. If the operation has a metadata key hierarchy, parameters that match with metadata keys *should* follow the same order.
+
** There’s no usage or relevance ranking
** Mixed
+
There might be a strong relevance among some group or subgroup of parameters, but another group (for example advanced or security) might not be.
+
For cases with no explicit relevance, alphabetic sorting *should* be used.
+
* Parameter Types
+
When working on Java based connectors, the connector *must not* expose types from external libraries.
+
For example: if is being used the MongoDB Library to create a MongoDB Connector, the result of the queries are represented as BSON objects. This could never be the output or input of an operation because of many reasons:
+
** The connector gets coupled to implementations that are not managed by the connector developer.
** The type is difficult or impossible to consume or create from DataWeave.
** The internal library gets shared on the application classloader and could cause class clashing.

=== Parameter Hints:

* @Example
+
For optional parameters that don’t specify a default, the @Example annotation *should* provide an example of a valid value. This increases the UX of Mule developers to be more sure about the kind and structure of data that they *should* configure.
+
NOTE: This applies to parameters of simple types only. It doesn’t include POJOs, lists or maps.
+
* Display Name
+
The SDK and Studio makes a best effort at transforming the parameter’s name to what is shown in the UI, but sometimes this is not enough. A name that makes sense on the connector’s DSL maybe doesn’t make sense in the UI and vice versa. For these cases, you *should* use the @DisplayName feature.
+
Also because the parameter name used on the extension is also the one used for the DSL (XML) and the display name, once the connector is released, this name can’t change since that would break backwards compatibility. The @DisplayName annotation is also useful in those cases to change the name shown in the UI without affecting backwards compatibility. Lastly, keep in mind that unlike Java or the Mule DSL, the @DisplayName does accept spaces.
+
* Expression Support
+
By default, parameters accept expressions. There are some cases in which this default *should* be changed. 
+
Disable expression support when it doesn’t make sense to support expressions in the context of a configuration or connection provider parameter, for example, the port number in which to place an http listener. It doesn’t make sense for the port of an inbound listener to be changing each time mule processes a message.
+
Make the use of expression mandatory when there’s no use case in which that parameter is to take a fixed value. For example, an aggregator’s group identifier.
+
* Summary
+
All parameters have a matching Javadoc that explains the purpose of that parameter and its semantics. Sometimes, that explanation can be quite lengthy. For those cases, it’s a good practice to use the @Summary annotation to provide a one liner description of the parameter. It’s ok if this summary doesn’t fully cover its meaning and purpose. It’s just intended to be a quick one liner that the UI can turn into a tooltip.
+
* Configuration Overrides
+
Sometimes a configuration object defines a parameter that *should* globally affect a connector. However, some components might want to override that parameter.
+
The canonical example of this is a charset encoding. A file connector could define the encoding to use at a configuration level. However, in the context of an application, one might have one specific flow in which a different encoding *should* be used (even though the rest of the application might still use the one specified in the config). The @ConfigOverride annotation *must* be used in these cases. This is not only a matter of simplifying your own code (as opposed to manually checking for an override and defaulting to the config one instead). The @ConfigOverride not only does that automatically, it also hints the Studio and Flow designer with the fact that the parameter is overriding a config parameter allowing the UI to surface this accordingly.
+
xref:mule-sdk::config-override.adoc[Configuration Overrides] are explained at length in this article.
+
* Putting the pieces together
+
Here’s an example of how the hinting features can interact together
+
[source,java,linenums]
---- 
@Parameter
@Optional
@Summary("The sender 'From' address. If not provided, it defaults to the address specified in the config")
 @Example("example@company.com")
 private String fromAddress;
----

=== Enum Versus Value Provider
	
There are use cases in which certain parameters are exposed to the user as a list of predefined values. 

Sometimes that list is fixed, meaning that all possible values to select from are already defined at compilation time and never change. An example of this is the protocol of an SFTP proxy. Possible values are HTTP, SOCKS4, and SOCKS5. That list is fixed and unaltered by any other condition. 

For cases like this, modules *must* use a xref:mule-sdk::value-providers.adoc#java_enum[Java Enum] as the parameter type. The Enum lists all the possible values and the SDK automatically generates the proper experience at design time.

Alternatively, the list of possible values can be dynamic and depends on other conditions.

For example, the Slack connectors allow users to send messages to different channels. The list of available channels actually depends on the logged user. Therefore, the list is dynamic.

To include values that are not known or dynamic, such as custom values, you *should* use xref:mule-sdk::value-providers.adoc#value_providers[Value Providers], instead.

When to use an Enum?

* When the values Set is well known
* When the value set is limited
* When the value set is not context dependant
* When the value set is closed
* When the required a combo inside a POJO (Value Providers are not supported inside POJOs)

When to use a Value Provider?

* When the values are not well known
* When the value set is context dependent depending on the Connection or Configuration or other parameters
* When the value set is open such that the connector can suggest some values, but other ones can also be valid
* When the value set is dynamic

=== Exclusive Parameters

If parameters values are invalid, modules *should not* fail at startup time or execution time. For example, the scripting module executes user scripts that can be provided either inline or referenced from a file. This module provides two parameters: one called script for the inlining option, and another called scriptFile. The user can use only one of these at a time, which means that they’re both optional. 

To provide a good user experience, the UI *should* provide hints to a user at design time when:

* The two parameters are provided at the same time
* No parameter is provided

Use cases like this *must* leverage the xref:mule-sdk::exclusive-optionals.adoc[Exclusive Optionals] feature to provide a good experience at design time.

=== Using POJO Parameters

Sometimes, you need to define parameters of POJO types. Depending on the scenario, that practice might be advised or simply discouraged. 

* Using POJOs for parameter grouping
+
One use case for a POJO parameter is when the same set of parameters constantly repeat across several components (either operations or sources). The Java good practice would be to put those together into a single reusable class.
+
For example, consider the Aggregators module, in which all group-based aggregators require a set of common parameters. This example creates the GroupBasedAggregatorParameterGroup class:
+
[source,java,linenums]
----
public class GroupBasedAggregatorParameterGroup extends TimeoutContainingAggregatorParameterGroup {

/**
 * An expression that determines the aggregation group unique ID. 
 * This ID determines which events *must* be aggregated together.
 */
@Parameter
@Expression(REQUIRED)
@Optional(defaultValue = "#[correlationId]")
private String groupId;

/**
 * The size of the expected group to aggregate. All messages with 
 * the same correlation ID *must* have the same groupSize.
 * If not, only the first message groupSize is considered and 
 * a warning is logged.
 */
@Parameter
@Expression(SUPPORTED)
@Optional
private Integer groupSize;

/**
 * The time to remember a group ID once it was completed or timed out.
 * 0 means, don't remember, -1 remember forever
 */
@Parameter
@Expression(NOT_SUPPORTED)
@Optional(defaultValue = "180")
private int evictionTime;

/**
 * The unit for the evictionTime attribute
 */
@Parameter
@Expression(NOT_SUPPORTED)
@Optional(defaultValue = "SECONDS")
private TimeUnit evictionTimeUnit;
}
----	
+
This object would then be used as follows:
+
[source,java,linenums]
----
@Alias("groupBasedAggregator")
@Throws(GroupBasedAggregatorErrorProvider.class)
public void aggregateByGroup(
       GroupBasedAggregatorParameterGroup aggregatorParameters,
       @Alias("incrementalAggregation") @Optional IncrementalAggregationRoute incrementalAggregationRoute,
       @Alias("aggregationComplete") AggregationCompleteRoute onAggregationCompleteRoute,
       RouterCompletionCallback completionCallback)
  throws ModuleException {

// impl...
}
----	
+
This approach however introduces some problems:
+
** The GroupBasedAggregatorParameterGroup object defines a complex type in the module’s type catalog, even though this type has no real semantic meaning for the module’s domain model. 
+
This is just a convenience internal type, derived from good practices of the programming language used to write the module. There would be no sense for this type to appear in the catalog.
+
* Because the type appears in the catalog, it becomes part of the module’s API. 
+
Therefore, modifications to it, or even the decision to replace it with something else, results in a backwards compatibility problem.
+
* Complex objects are hard to translate into a good user experience in Studio and Flow Designer.
+
All of the these issues can be traced to one root cause: the module’s structure *should not* reflect nor be affected by the nuances of the programming language being used (notice that we wouldn’t be having this discussion if the XML SDK would be used here instead).
+
To be able to still maintain parameters in a POJO without generating the side effects in the generated module, use the @ParameterGroup annotation:
+
[source,java,linenums]
----
public void aggregateByGroup(
       @ParameterGroup(
           name = "Aggregator config") GroupBasedAggregatorParameterGroup aggregatorParameters,
       @Alias("incrementalAggregation") @Optional IncrementalAggregationRoute incrementalAggregationRoute,
       @Alias("aggregationComplete") AggregationCompleteRoute onAggregationCompleteRoute,
       RouterCompletionCallback completionCallback)
  throws ModuleException {

// implemented as privileged operation in GroupBasedAggregatorOperationsExecutor
}
----	
+
This annotation opens the POJO and exposes its inner parameters, as if they had been inlined as method arguments. As far as the user and the type catalog know, there’s no GroupBasedAggregatorParameterGroup and the operation simply defines multiple String parameters. However, the developer still needs to leverage the Java POJO.
+
* Forcing child elements in the Mule DSL
+
Another use case for POJO parameters is forcing certain parameters to appear as child elements in the Mule DSL. For instance, consider this example from the email connector:
+
[source,xml,linenums]
----
<email:send config-ref="${sender-config}" fromAddress="juan.desimoni@mulesoft.com"
          subject="Email Subject">
  <email:to-addresses>
      <email:to-address value="sebastian.elizalde@mulesoft.com"/>
  </email:to-addresses>
  <email:body contentType="text/plain">
      <email:content>Email Content</email:content>
  </email:body>
</email:send>
----
+
The <email:body> is a POJO that contains the content and contentType parameters. Because the email connector is quite complex, we want the body to appear as a child element in the Mule DSL, for increased readability.
+
To use a POJO just for this has the same drawbacks as in the prior example, but again, you can use the @ParameterGroup annotation to overcome them:
+
[source,java,linenums]
----
@Summary("Sends an email message")
@Throws(SendErrorTypeProvider.class)
public void send(@Connection SenderConnection connection,
       @Config SMTPConfiguration configuration,
       @Placement(order = 1) @ParameterGroup(name = "Settings") EmailSettings settings,
       @Placement(order = 2) @ParameterGroup(name = "Body", showInDsl = true) EmailBody body,
       @Placement(order = 3) @ParameterGroup(name = "Attachments") AttachmentsGroup attachments) {
----
+
As you can see, the @ParameterGroup annotation has a showInDsl attribute that can be used to force the DSL to put the inner parameters as a child element. 
+
* Defining Global Elements
+
Another use case is the ability to define a global element (which is not a Configuration) to referenced from another component.  
+
For example, the File connector has the concept of a matcher, which is a set of rules that are used to decide whether a file *should* be processed or ignored. Matchers can be used in either the <file:list> operation or in any of the message sources defined in the connector.
+
Because the exact same matcher might be needed in different flows, the connector provides the ability to define global matchers than can be later referenced. For example:
+
[source,xml,linenums]
----
<file:matcher name="matcher" filenamePattern="*.txt"/>

<flow name="listenTxtOnly">
  <file:listener config-ref="file" directory="withMatcher" matcher="matcher" autoDelete="true">
      <scheduling-strategy>
          <fixed-frequency frequency="1000"/>
      </scheduling-strategy>
  </file:listener>

  <flow-ref name="processTxtFile"/>
</flow>
----	
+
For these cases, it makes sense to define the matcher parameter as a POJO, without the use of the @ParameterGroup annotation. Notice that in this case, having the concept of a matcher being listed in the connector’s type catalog makes sense, since this is not an implementation detail but a core piece of functionality.
+
There’s one caveat though: for this to work, the class in which the matcher is implemented needs to declare that it is to be used as a global element:
+
[source,java,linenums]
----
@Alias("matcher")
@TypeDsl(allowTopLevelDefinition = true)
public class LocalFileMatcher {

/**
 * Files created before this date are rejected.
 */
@Parameter
@Summary("Files created before this date are rejected.")
@Optional
private LocalDateTime createdSince;

/**
 * Files created after this date are rejected
 */
@Parameter
@Summary("Files created after this date are rejected")
@Optional
private LocalDateTime createdUntil;
...
}
----	
+
* DSL Decision Making
+
As a summary, here’s a simple flow chart to aid with the decision process of how to use POJOs and parameter groups.


== Defining Sources

=== Assure Restartability

Tools like Anypoint Runtime Manager allow you to start and stop individual sources or flows, independently from the rest of the application. 

This means that all sources must:

* Be able to be stopped and restarted at any time, without their functionality being affected
* Release all resources when stopped including connections, threads, files, and so on.

=== No Manual Polling

Sources that work by doing polling *must not* implement the polling logic manually. They *must* extend the PollingSource class instead.

=== Declare When a Response Is Emitted

There are sources that only trigger messages into a flow. Others, also send a response to an external system, like the HTTP connector.

Sources that emit a response *must* be annotated with xref:mule-sdk::sources-response.adoc[@EmitsResponse].

=== Handle Asynchronous Callbacks

Sources define callbacks (methods annotated with @OnSuccess and/or @OnError) in which asynchronous tasks are performed. These async tasks can range from sending a response using non-blocking I/O to sending notifications or auditing tasks.

For asynchronous callbacks, the source *must* use SourceCompletionCallback to signal the completion of such tasks. See xref:mule-sdk::sources-async-response.adoc[Sending Asynchronous Responses from a Message Source].

=== Use Transactions

When the source obtains its messages from a transactional system, it *must* do so using xref:mule-sdk::transactions.adoc[transactions].

=== Handle Back Pressure

The Mule xref:mule-runtime::execution-engine.adoc[execution engine] may apply back pressure to a message source when at capacity. By default, the SDK forces the source to wait when back pressure occurs by making this method block and wait for Mule to have resources available to handle the request:

`org.mule.runtime.extension.api.runtime.source.SourceCallback#handle(org.mule.runtime.extension.api.runtime.operation.Result<T,A>)`

Although this default behavior suits most cases, some modules require different actions. For example:

* Instead of waiting, the HTTP connector sends a 503 response
* The JMS connector makes it configurable if the source *should* wait, fail, or drop the message, as those are valid options in the messaging domain

When the module’s domain includes use cases in which waiting *should not* be the default, or additional options *should* be available, then the source *must* use the @BackPressure annotation to provide that behavior.

==== Custom Actions When Back Pressure Occurs

Some modules may need to take custom actions when back pressure errors occur, such as:. 

* Resolving transactions
* Releasing resources
* Sending notifications to external systems

Modules with this functional need *must* do so by including a callback method annotated with @OnBackPressure. For example:

[source,java,linenums]
----
@OnBackPressure
public void onBackPressure(BackPressureContext ctx) {
  // .. implementation
}
----	

Notice that if the action to be taken is asynchronous, a SourceCompletionCallback *must* be leveraged too:

[source,java,linenums]
----
@OnBackPressure
public void onBackPressure(BackPressureContext ctx, SourceCompletionCallback completionCallback) {
  // .. implementation
}
----

==== Resolving Transactions

If the source is transactional, then it *must* add a back pressure handler in which the transaction is resolved.

=== Mind the Cluster Behavior

All sources *must* consider how they are going to behave when Mule operates in cluster mode or the same app is deployed to several workers in CloudHub.

In some cases, it’s okay for the source to run on all replicas. An example of this is the <http:listener>. The underlying protocol already guarantees that no two nodes will pick up the same file at the same time. This is the default behavior.

However, there are some cases in which the source *should* run on the primary node only, as running on all replicas could lead to bogus behavior or data corruption. An example of this is a `<jms:listener>` that is listening to a topic, or a source reading from a stream of events. In these cases, a source *must* be annotated with the @ClusterSupport annotation, and specifying the NOT_SUPPORTED or DEFAULT_PRIMARY_NODE_ONLY options.

=== Display Name

Sources *should* have a @DisplayName that uses the “On ..” prefix to communicate in which event or action the source/listener/trigger will be executed/triggered, for example: 

* JMS Connector
+
The source is called On New Message communicating that the source will dispatch a message when a new message arrives to a Queue.
+
* Database Connector
+
On Table Row communicates that triggers for each table row.
+
* Salesforce Connector
+
On Created Object, every time the connector detects a new object in Salesforce, the connector triggers the flow.

==== DSL Naming

At the DSL level, the sources  *should* instead use the `listener` suffix, or simply use the listener name.

For example:

* The HTTP connector defines the <http:listener> message source for exposing inbound HTTP endpoints
* The WebSockets connector defines the <ws:inbound-listener> and <ws:outbound-listener> sources

These can be controlled using the @Alias annotation.

== Error Handling

=== Defining Error Types

The module *must* define an error type for all business related or technical conditions that can be expected and make sense for the user to want to handle specifically. 

Examples of conditions that *should* have a matching error type:

* Entity referenced by ID does not exists
* Account has no funds
* User is unauthorized
* User lacks privileges to perform a certain action
* Remote system is at capacity

Examples of conditions that *should not* have a matching error type:

* Network error
* Unexpected server error
* Unknown error

=== Use Error Hierarchies

Mule 4 Error types support the concept of hierarchies. That means that an error can stand on its own, or it can be a child of another ErrorType defined in the same module or defined as a generic Mule Error.

Leveraging Mule 4 error handling allows the user to reuse generic error handlers that tackle generic problems in consistent ways. For example, imagine a flow that uses multiple connectors in the same flow and wants to trigger a specific alert when a connectivity issue appears. If all the connectors in that flow use MuleErrors.CONNECTIVITY as the parent error for all connectivity problems, then that becomes easy to accomplish.

The same applies internally for any module that defines error types that hold some kind of internal relationship. 

Here's an example taken from the WebSockets connector:

[source,java,linenums]
----
public enum WsError implements ErrorTypeDefinition<WsError> {

CONNECTIVITY(MuleErrors.CONNECTIVITY),
CLIENT_SECURITY(MuleErrors.CLIENT_SECURITY),
SERVER_SECURITY(MuleErrors.SERVER_SECURITY),
BASIC_AUTHENTICATION(SERVER_SECURITY),
UNAUTHORIZED(CLIENT_SECURITY),
FORBIDDEN(CLIENT_SECURITY),
NOT_FOUND,
SERVICE_UNAVAILABLE,
NO_SUCH_SOCKET,
INVALID_SOCKET_ID,
NON_UNIQUE_SOCKET_ID,
REMOTELY_CLOSED,
INTERNAL_SERVER_ERROR;

private ErrorTypeDefinition<? extends Enum<?>> parent;

WsError(ErrorTypeDefinition<? extends Enum<?>> parent) {
  this.parent = parent;
}

WsError() {}

@Override
	public Optional<ErrorTypeDefinition<? extends Enum<?>>> getParent() {
	  return Optional.ofNullable(parent);
	}
}
----

In this example you can see how:

* To define error types with parents
* The CONNECTIVITY error extends the Mule one
* The CLIENT_SECURITY and SERVER_SECURITY errors are defined
* BASIC_AUTHENTICATION, FORBIDDEN, and UNAUTHORIZED errors extend CLIENT_SECURITY and SERVER_SECURITY 
* The set of other errors that are domain-specific and stand on their own

=== Correct Use of Module Exception

The ModuleException class (or a custom subclass of it) *must* be thrown only when an error matches a defined ErrorType. Unexpected or non-handable errors that do not have a 
matching ErrorType *must* be thrown as regular exceptions.

=== Avoid Proliferation of Error Types

A common anti-pattern is to excessively apply the concept of “one error type per business error” into “one error type for every error detail”. An example of that is creating errors like INVALID_EMAIL, INVALID_ID, INVALID_NAME, INVALID_CARD, and so on, that lead to an explosion of types that makes the feature unusable. 

The module *must* collapse error types of similar semantics and leverage the exception message instead. So per the previous example, only one ErrorType called INVALID_DATA *should* exist, and then the exception message can provide additional context on whether the problem was the credit card, client name, and so on. 

Notice that this rule is closely related to the previous concept of “the error has to be handleable” as it’s extremely unlikely that an end user will want to catch an invalid ID and invalid email differently (simply think of how many times have you actually done that in Java in your life).

=== Do Not Expose Exceptions or Error Types

Exception, ErrorTypeDefinition, and ErrorTypeProvider classes defined in the module *must not* be exported as part of its API.

== HTTP-Based Connectors

There’s a special set of considerations for connectors that access a remote system by either issuing HTTP requests or exposing HTTP endpoints.

=== Use the Mule HTTP Client

The Mule HTTP Client *must* be used for making HTTP requests. Other HTTP clients (such as  the Jersey client, Apache HTTP Client, Jetty, Netty, and so on) *should not* be used in favor of the Mule HTTP client.

The only exception to this rule is when the remote system vendor already provides a client library that has some level of added value that would be too difficult to replicate with the use of the Mule HTTP Client.

For example, the Amazon AWS connectors work by consuming an HTTP API that requires custom message signing. Amazon provides a client library that encapsulates the logic necessary to make such signing. 

However, a client library that does nothing but wrap an HTTP client for convenience (like the Google clients) is not a valid exception to this rule.

* Handle the HTTP Client Lifecycle
+
The ConnectionProvider that creates the HttpClient is responsible for managing its lifecycle. 
+
* Use Cached Connection Providers
+
Every ConnectionProvider that creates an HttpClient *must* implement the CachedConnectionProvider interface. 
+
Notice that this rule has implications on the connection object that the Connection Provider can yield. Because of the previously discussed Connection Object *must not* expose (nor be) the inner client rule, this means that the provided connection object needs to contain the HTTP client as part of its state and *must* be thread safe.
+
* Use Startable and Stoppable Connection Providers
+
The Connection Provider *must* also implement the Startable and Stoppable interfaces. The HttpClient *must* be created and started during the start() phase and *must* be stopped during the stop() phase.
+
Lifecycle example:
+
[source,java,linenums]
----
public class HttpConnectionProvider implements CachedConnectionProvider<HttpConnection>, Startable, Stoppable {
        
        @Inject
        private HttpService httpService;

        @Parameter
        private TlsContextFactory tlsContext;

        @Override
   public void start() throws MuleException {
       initialiseIfNeeded(tlsContext);
       httpClient = httpService.getClientFactory().create(getHttpClientConfiguration());
       httpClient.start();
   }

   @Override
   public void stop() throws MuleException {
           if (httpClient != null) {
              httpClient.stop();
           }
   }

   // rest of the implementation removed for example simplicity

}
----	
+
* Set the HTTP Client Name
+
The HttpClient created by each ConnectionProvider *must* have a name which is based on (or simply matches) the name of the configuration that owns that ConnectionProvider. 
+
This is very important for performance troubleshooting. Each HttpClient creates a set of selector threads that it uses for I/O. Those threads are named after the client’s name. Giving those threads a meaningful name is key for diagnosing performance problems.
+
The name of the owning config can be obtained using the @RefName annotation.
+
Here’s an example of how to do this:
+
[source,java,linenums]
----
public class HttpConnectionProvider implements 
	CachedConnectionProvider<HttpConnection>, Startable, Stoppable {
        
        @Inject
        private HttpService httpService;

        @RefName
        private String configName

        @Override
   public void start() throws MuleException {
       httpClient = httpService.getClientFactory().
       	create(new HttpClientConfiguration.Builder()
                       .setName(configName)
                       .build());
       httpClient.start();
   }

   // rest of implementation removed for example simplicity

}
----	
+
* Leverage Non-Blocking I/O in Operations
+
The HttpClient is capable of using non-blocking I/O to make the requests. Operations *must* leverage this capability and also be defined as non-blocking.
+
* Do not reference <http:requester-config> Elements
+
The HttpService allows you to obtain the HttpClient associated with a separate <http:requester-config> element. Although this capability exists, it is not meant to be used by connectors. Connectors *must not* use this feature. 
+
All connectors in need of a HttpClient instance, *must* create and manage their own.
+
* Provide HTTP Proxy settings
+
Connectors using HttpClient instances *should* provide the ability to configure a proxy, in a manner that is consistent with the standard HttpConnector.
+
Examples of how to do that can be found in the Http Connector code.

=== Exposing HTTP Inbound Endpoints

Some connectors need to expose their own HTTP inbound endpoints.

To achieve this, connectors *must* reference an external <http:listener-config> element to obtain an HttpServer instance. Connectors *must not* create their own servers.

This *must* be achieved as follows:

* Correctly reference the listener config
+
The connection provider *must* expose a String parameter called listenerConfig. This parameter *must* be of type String, not accept expressions, and use the @ConfigReference annotation to indicate that it points to an <http:listener-config> element. 
+
For example:
+
[source,java,linenums]
----
@Parameter
@Expression(NOT_SUPPORTED)
@ConfigReference(name = "LISTENER_CONFIG", namespace = "HTTP")
private String listenerConfig;
----
+
* Add a RequestHandler 
+
Using the listenerConfig parameter added above, a matching HttpServer instance can be obtained like this:
+
[source,java,linenums]
----
HttpServer httpServer;
try {
        httpServer = httpService.getServerFactory().lookup(listenerConfig);
        } catch (ServerNotFoundException e) {
        throw new IllegalArgumentException(
           format("Connector configuration '%s' refers to an <http:listener-config> with name '%s', "
               + "but such element doesn't exist", configName, listenerConfigName),
           e);
}
----	
+
With the obtained HttpServer, a new RequestHandler can be added using the org.mule.runtime.http.api.server.HttpServer#addRequestHandler(java.lang.String, org.mule.runtime.http.api.server.RequestHandler) method.
+
The connector *must* carefully follow the contract defined in the Javadocs for that method. Most importantly, invoking that method will return a RequestHandlerManager instance. Those instances *must* be kept by the connector as they expose two important methods: start() and stop().
+
The inbound endpoint will not be actually functioning until the start() method is invoked on the RequestHandlerManager. At the same time, the endpoint does not go away until the stop() method is invoked on the RequestHandlerManager.
+
That means that when the component owning the custom endpoint is stopped, so *must* the RequestHandlerManager be stopped. Otherwise, your connector will generate a memory leak.

=== Make Timeouts Configurable

The connector *must* expose a parameter that controls the timeout of the HTTP requests. 

This *must* be done in a way that is consistent with the previously discussed rules about how to handle duration parameters and making timeouts Config Override parameters.

=== HTTPS Security

The connector *must* support the HTTPS scheme whenever possible and *must* consider it as the recommended option:

* If the remote system supports only HTTPS, then the connector *must* have a required TlsContextFactory parameter.
* If the remote system supports both HTTP and HTTPS schemes, then the connector *must* support both options but log a warning when HTTP is used.

== Threading and Asynchronous Processing

Most modules *should not* have concurrency concerns other than designing for Thread safety.

However, there are some very valid use cases in which a module needs to either perform tasks asynchronously or schedule recurring tasks. This section elaborates on the best practices for doing that.

As you go through this section, keep in mind that when we refer to a Scheduler, we’re actually referring to an instance of the org.mule.runtime.api.scheduler.Scheduler class.

NOTE: Do not confuse asynchronous processing with non-locking I/O. These are not the same thing.

=== Don’t Create Your Own Threads or Executors

Modules *must not* create their own Threads, Executors or ExecutorServices. Any asynchronous tasks *must* be done by obtaining a Scheduler from Mule’s SchedulerService.

The SchedulerService API is very well documented in its Javadocs. Be mindful of the contracts documented there and use them accordingly.

==== Dependency-Created Threads

Sometimes a module has no choice but to depend on an external source to create its own threads. For example:

* A JMS connector that depends on broker libraries to create its own consumer Threads
* A client library that spawns its own I/O selector Threads
* A JDBC driver that spawns its own Threads

As these cases are unavoidable, they are valid exceptions to this rule. However, the following conditions *must* be met:

* When there’s no viable alternative and there’s no point in creating your own JMS broker just for the sake of being in control of the Threads
* The Threads created by these libraries *must* have a meaningful name

Keep in mind that some libraries may allow you to pass an Executor instance and fall back to create its own threads if not provided. In such cases, passing the executor *should* be the method you use. Refer to the custom Schedulers section that follows for additional details.

=== Do Not Use Schedulers for Polling in Sources

Sources *must not* create Schedulers with the purpose of doing polling. Extend the PollingSource class instead.

=== Manage Schedulers Lifecycle

As most things in Mule, Schedulers have a lifecycle that *must* be carefully handled.

* Choose the correct Scheduler type
+
The Scheduler Service provides three types of Schedulers:
+
** CPU Light
+
These schedulers *should* be used for asynchronous tasks that complete really quickly without significant CPU consumption. They can also be used for tasks that perform non-locking I/O. Examples include simple validations, light calculations, or any kind of logic that doesn’t perform I/O and takes around 10 ms to complete.
+
** CPU Intensive 
+
For tasks that perform intensive CPU computation. No I/O operations or long blocking, such as waiting for a lock held by an I/O thread while doing I/O *should* be performed here. Examples include encryption, heavy transformations, expensive validations, and any other kind of logic that doesn’t perform I/O and makes heavy use of the CPU for more than 20 ms.
+
** IO Scheduler 
+
For blocking I/O operations, such as writing to an FTP site, accessing a relational database, and so on.
+
Tasks submitted to any of these Schedulers *must* be compliant with the type of work that each Scheduler is meant to handle. These schedulers are slices of the main thread pools used by the Mule 4 xref:mule-runtime::execution-engine.adoc[Execution Engine]. Failing to comply with each Scheduler work profile can lead Mule to operate with sub-optimal performance.
+
* Custom Schedulers
+
There are certain types of Schedulers that don’t completely fit into the profile of any of the three Scheduler types. Custom Schedulers *should* be used for:
+
** Tasks that execute and repeat at a fixed rate (and *should not* be part of a PollingSource). Examples include (but are not limited to):
*** Cache expiration tasks
*** Resource releasing tasks
*** I/O selectors
*** Queue consumers
*** Tasks that require their own thread pool
*** Tasks that have a mixed profile that doesn’t completely fix any of the previous criteria
+
* Give Schedulers a meaningful name
+
All Schedulers obtained through the SchedulerService *must* be assigned with a meaningful name that refers to:
+
** The name of the module that created the Scheduler
** The name of the configuration object for the component that created the Scheduler or its position in a flow
** The Scheduler purpose
+
* Define the owning Component
+
An important aspect of managing your own Schedulers is defining which component *should* own it:
+
** If the Scheduler is to be used by a source, then the Scheduler  *must* be defined as part of that source
** If the Scheduler is used for releasing connection related resources, then it *should* be owned by a ConnectionProvider
** If the Scheduler performs tasks not specific to any component, or many components will receive tasks from different components, then it *should* be owned by a configuration object
+
The owning component *must* be one that is lifecycle aware. This means that at a minimum it *must* either:
+
** Implement the Initialisable and Disposable interfaces
** Implement the Startable and Stoppable interfaces
+
* Never create Schedulers at the operation level
+
Schedulers *must* never be created in operation classes. If an operation requires the use of a Scheduler, then it *must* be created at a config element level and the Scheduler shared across all operations.
+
* Make a best effort to share Schedulers
+
Modules *should* create as many Schedulers as needed, but as few as possible. There are use cases in which it makes sense for different components to have their own Schedulers, but a best effort *must* be made to share and reuse Schedulers across components.
+
* Guarantee that all Schedulers are stopped
+
All created Schedulers *must* be guaranteed to eventually invoke the stop() method. Invocation of this method *should* be tied to the lifecycle of the component that owns it. For example, if the Scheduler is owned by a configuration element, then that component *should* implement the Stoppable interface and invoke it as part of its own stop() call. Sources *should* do it during the onStop() method and so forth.

=== Scheduler Lifecycle Example

This example of a Source-owned Scheduler applies all the lifecycle concepts:

[source,java,linenums]
----
public class ExampleSourceScheduler extends Source<Serializable, VMMessageAttributes> {

 @Inject
 private SchedulerService schedulerService;

 @Inject
 private SchedulerConfig schedulerConfig;

 private ComponentLocation location;
 private Scheduler scheduler;

 @Override
 public void onStart(SourceCallback<Serializable, VMMessageAttributes> sourceCallback) throws MuleException {
   scheduler = schedulerService.customScheduler(schedulerConfig
       .withMaxConcurrentTasks(numberOfConsumers)
       .withName("vm-listener-flow " + location.getRootContainerName())
       .withWaitAllowed(true)
       .withShutdownTimeout(5, SECONDS));
 }

 @Override
 public void onStop() {
   if (scheduler != null) {
     scheduler.stop();
   }
 }
}
----	

== Security

The module *must* follow all standard security best practices.

In particular, the following *should* be given special consideration:

* Protect against XXE attacks
* Always sanitize information from untrusted sources
* When reading files from the local file system, make sure not to access secrets of the host environment nor enable path traversal
* When possible, use CSRF tokens
* When executing queries to a database, make correct use of PreparedStatement class to avoid SQL injection attacks.

== See Also

https://help.mulesoft.com[MuleSoft Help Center]
