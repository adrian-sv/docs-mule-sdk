= Client Credentials
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: mule, sdk, grant, oauth

Available since version 1.3.

Unlike the Authorization Code grant type, which focuses on authorizing an application that wants to act on a user's behalf, the Client Credentials grant type focuses on authorizing an application acting on its behalf. This grant type is better suited for machine-to-machine communication as it doesn't require human intervention.

== Develop a Client Credentials-enabled Connector

You can add Client Credentials support at the ConnectionProvider level through the @ClientCredentials annotation.

Here is an oversimplified ConnectionProvider example for the Salesforce connector:

[source, java, linenums]
----
@ClientCredentials(tokenUrl = "https://login.salesforce.com/services/oauth2/authorize")
public class SalesforceOAuthConnectionProvider<C> implements ConnectionProvider<SalesforceClient> {

   @Parameter
   @Optional(defaultValue = "34.0")
   private Double apiVersion;

  /**
   * Tailors the login page to the user's device type.
   */
  @OAuthParameter
  private String display;

  /**
   * Avoid interacting with the user
   */
  @OAuthParameter
  @Optional(defaultValue = "false")
  private boolean immediate;

  /**
   * Specifies how the authorization server prompts the user for reauthentication and reapproval
   */
  @OAuthParameter
  @Optional(defaultValue = "true")
  private boolean prompt;

  @OAuthCallbackValue(expression = "#[payload.instance_url]")
  private String instanceId;

  @OAuthCallbackValue(expression = "#[payload.id]")
  private String userId;

  private AuthorizationCodeState state;

  @Override
  public SalesforceClient connect() throws ConnectionException {
    if (state.getAccessToken() == null) {
      throw new SalesforceException(MessageFormat.format(COULD_NOT_EXTRACT_FIELD, "accessToken"));
    }

    if (instanceId == null) {
      throw new SalesforceException(MessageFormat.format(COULD_NOT_EXTRACT_FIELD, "instanceId"));
    }

    return new SalesforceClient(state.getAccessToken(), instanceId, apiVersion);
  }

  public void disconnect(SalesforceClient connection) {
    connection.close();
  }

  @Override
  public ConnectionValidationResult validate(SalesforceClient connection) {
    return success();
  }
}
----

The class implements ConnectionProvider, just like other connections in the SDK. Operations that are authenticated through the object operate over the SalesforceClient object that the provider returns. This is an important design consideration because it permits you to decouple the operation from the authentication method that is used because the connector could define another ConnectionProvider that uses  basic authentication, and all the operations remain fully compatible.

=== @ClientCredentials

This annotation indicates that this connection provider requires an OAuth dance using the Client Credentials grant type. The annotation has the following attributes:

[source, java, linenums]
----
public @interface ClientCredentials {

  /**
   * @return The Url of the endpoint which provides the access tokens
   */
  String tokenUrl();

  /**
   * @return Expression to be used on the response of {@link #tokenUrl()} to extract the access token
   */
  String accessTokenExpr() default "#[payload.access_token]";

  /**
   * @return Expression to be used on the response of {@link #tokenUrl()} to extract the access token expiration
   */
  String expirationExpr() default "#[payload.expires_in]";

  /**
   * @return The default set of scopes to be requested, as a comma separated list. Empty string means no default scopes.
   */
  String defaultScopes() default "";

  /**
   * Allows to customize the placement that the client credentials will have in the request.
   *
   * @return the selected {@link CredentialsPlacement}. Defaults to {@link CredentialsPlacement#BASIC_AUTH_HEADER}
   */
  CredentialsPlacement credentialsPlacement() default BASIC_AUTH_HEADER;

}
----

=== Connection Management Strategy

The provider in the previous example does not implement any specialization of the ConnectionProvider interface, which means that the OAuth mechanism can be combined with the other connection management strategies. The connection objects can be pooled, cached, or created from scratch each time, depending on which interface is used (for example, PoolingConnectionProvider, CachedConnectionProvider, ConnectionProvider, and so on). For more information on connectivity management, see the connectivity reference.

Be aware of the semantics of using the vanilla ConnectionProvider interface in this scenario. In a regular, “non-oauth” connection provider, using the vanilla interface means that each time a component requires a connection, a new one is created, and it is destroyed when the component is finished. Although this will remain true for the OAuth case, it does not mean that the OAuth dance is performed again. New connection objects are created, but the same access token is reused as long as it remains valid.

=== Regular Parameters versus OAuth Parameters

This ConnectionProvider can have parameters, just like any other connection provider. However, you must distinguish regular parameters from the concept of @OAuthParameter.

An OAuthParameter is included as a custom parameter while performing the OAuth dance. So, for example, while the apiVersion parameter is something that the connection provider uses to create the SalesforceClient, the immediate parameter is actually sent on the OAuth request to the service provider.

From the module’s point of view, it is just another parameter for which the user provides a value. You can combine these parameters with @Optional, @Expression, and all the other annotations you can use with the traditional @Parameter annotation. In the DSL, regular and OAuth parameters appear together. The module’s end user should not notice any difference.

== Request Alias

Some custom OAuth parameters might include characters that are not supported in Java. For example "Api-Key". Since you cannot use "-" as part of a field name, the @OAuthParameter annotation has an optional parameter called requestAlias. For example:

[source, java, linenums]
----
@OAuthParameter(requestAlias = "api-key")
private String apiKey;
----

=== @OAuthCallbackValue

Callback values are extracted from the response that the service provider sends through the OAuth callback. Although most service providers simply return standard items (such as access and refresh tokens, expiration information, and so on), some others return additional items. In the Salesforce case, they return user and instance IDs.

The annotation includes an expression that is applied on the response to extract the value. That value is then assigned to the field for the connection provider to use. When the connect(), validate() or disconnect() methods are invoked, the fields are set and usable.

=== @ClientCredentialsState

Every ConnectionProvider annotated with @ClientCredentials MUST contain one (and only one) field of type ClientCredentialsState.

It is a simple immutable POJO that contains information regarding the outcome of the OAuth dance. It contains the following information:

[source, java, linenums]
----
public interface ClientCrendentialsState {

  /**
   * @return The obtained access token
   */
  String getAccessToken();

  /**
   * @return The access token's expiration. The actual format of it depends on the OAuth provider
   */
  Optional<String> getExpiresIn();
}
----

Through this object, the provider gains access to the accessToken and other standard information that was obtained during the OAuth dance. The original Salesforce example shows how the connect() method makes use of this POJO to create the client.

== Configure a Client Credentials Connector

An important aspect of OAuth-enabled modules is how to use them. As much as the SDK does to hide the complexities of the OAuth protocol, things like the OAuth dance are unavoidable. The SDK’s approach to this problem is to standardize the experience of all OAuth modules to keep simplifying the user experience.
This section discusses the steps a user must take to use the module.

=== Synthetic Parameters
In addition to everything explicitly defined in the ConnectionProvider, the SDK automatically adds some extra parameters and injects the proper behavior for them.

[cols="1,1,1,2,2", options="header"]
|===
|Parameter Name
|Required
|Expressions
|Default Value
|Description

|`clientId`
|YES
|SUPPORTED
|N/A
|The OAuth `clientId` as registered with the service provider.

|`clientSecret`
|YES
|NOT_SUPPORTED
|N/A
|The OAuth `clientSecret` as registered with the service provider.

|`tokenUrl`
|NO
|SUPPORTED
|Value provided in the @ClientCredentials annotation.
|The service provider's token endpoint URL.

|`scopes`
|NO
|SUPPORTED
|Value provided in the @ClientCredentials annotation.
|The OAuth scopes to be requested during the dance. If not provided, it defaults to those in the annotation.

|`objectStore`
|NO
|NOT_SUPPORTED
|N/A
|A reference to the ObjectStore used for storing each resource owner ID’s data. If not specified, the runtime automatically provisions the default one.
|===

=== About the Use of Expressions

The previous table identifies many of the synthetic parameters that accept expressions. Using expressions there has the same effect as using expressions in a regular parameter: it turns the configuration into a dynamic one.

=== OAuth Connection DSL

The following example shows  generated DSL:

[source, java, linenums]
----
<sfdc:config name="salesforce">
    <sfdc:client-credentials-connection display="PAGE" immediate="FALSE" prompt="CONSENT">
        <sfdc:oauth-client-credentials clientId="${sfdc.consumerkey}" clientSecret="${sfdc.consumersecret}" tokenUrl="http://..." />
        <sfdc:oauth-store-config objectStore="oauthObjectStore" />
</sfdc:config>
----

Regular and OAuth parameters are all shown at the connection provider level, just like in any other provider.
The parameters related to the Client Credentials grant type are placed on a child element called <oauth-client-credentials>.
The parameters related to ObjectStore will be placed in a child element called <oauth-store-config>.

=== Configuring a Custom ObjectStore

The obtained access tokens are stored in an ObjectStore. By default, the SDK stores them in the app’s default store, but users can define their own custom one, as shown in this example:

[source, java, linenums]
----
<os:object-store name="tokenStore"
   entryTtl="1"
   entryTtlUnit="HOURS"
   maxEntries="100"
   persistent="true"
   expirationInterval="30"
   expirationIntervalUnit="MINUTES" />

<sfdc:config name="salesforce">
    <sfdc:client-credentials-connection display="PAGE" immediate="FALSE" prompt="CONSENT">
        <sfdc:oauth-client-credentials clientId="${sfdc.consumerkey}" clientSecret="${sfdc.consumersecret}" tokenUrl="http://..." />
        <sfdc:oauth-store-config objectStore="tokenStore" />
</sfdc:config>
----

== Handling Expired Client Credentials Access Token

Most service providers return (or should return) access tokens with a limited lifespan. In general, access tokens usually expire about 30 to 60 minutes after being issued, although this is not a standard that is strictly enforced by providers.
In the same way, providers often provide a refresh token with the access token. The refresh token is a second token that can be used to replace an expired access token with a fresh one, without the need to perform the OAuth dance again.
There is not an enforced standard that the SDK can use to automatically detect a token expiration scenario and obtain a new one. Different APIs communicate that in different ways. That is why the AccessTokenExpiredException exception exists, shown below:

[source, java, linenums]
----
public void someOperation(@Connection SalesforceRestClient client) {
    Response response = client.performSomeOperation();
    if (response.getStatusCode() == 401) {
        throw new AccessTokenExpiredException();
    }
}
----

The example above uses an imaginary REST client to perform an operation.

* It assumes that this rest client was created through a ConnectionProvider annotated with @ClientCredentials.
* It performs the operation and gets a Response object that contains information of the HTTP call.
* The example assumes that a status code of 401 (UNAUTHORIZED) means that the token has expired.
* It throws the AccessTokenExpiredException.

When the SDK detects this exception, it automatically performs the refresh dance and retries the operation with a new access token.
Note that, in practice, different APIs notify you of the access token expiration in different ways. Some give you clients that throw exceptions, while others give you custom messages. You should research the remote API to determine the best way to account for this.

=== Invalidating Access Tokens

Multi-tenancy implies the ability to invalidate the access token of a particular resourceOwnerId. Invalidating the token causes the associated token information to be deleted.
To invalidate an access token, the SDK automatically adds an operation called `unauthorize` to every OAuth-enabled module. Returning to the example above, you might invalidate the token obtained like this:

[source, java]
----
<sfdc:unauthorize config-ref="salesforce"/>
----

Note that this operation does not invalidate the token on the Service Provider. It removes the Service Provider from Mule’s caches and ObjectStores.
